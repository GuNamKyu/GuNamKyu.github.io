<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>
</head>
<body>
<script type="text/javascript">
/*
	let member = ['egoing', 'k8805', 'sorialgi'];
	alert(member[0]);
	alert(member[1]);
	alert(member[2]);
	// 'egoing', 'k8805', 'sorialgi'는 원소(element)
	// 0,1,2는 색인(index)
*/

/*
function get_members(){
    return ['egoing', 'k8805', 'sorialgi'];
}
let members = get_members();
document.write(members[0]);
document.write(members[1]);
document.write(members[2]);
*/

/*
function get_members(){
    return ['egoing', 'k8805', 'sorialgi', 'leezche'];
}

members = get_members();
for (let i = 0; i< members.length; i++){
	document.write(members[i].toUpperCase());
	document.write('<br/ >');
}
*/

// members.length는 members라는 배열에 담긴 값의 숫자를 알려준다. 

/*
let li = ['a', 'b', 'c', 'd', 'e']
li push('f');
alert(li);
//push = 하나의 원소 추가

let li = ['a', 'b', 'c', 'd', 'e']
li = li.concat(['f', 'g']);
alert(li);
// concat = 하나의 배열 추가

let li = ['a', 'b', 'c', 'd', 'e']
li.unshift('z');
alert(li);
// unshift = 하나의 원소를 맨앞에 추가

let li = ['a', 'b', 'c', 'd', 'e']
li.splice(2, 0, 'B');
alert(li);
*/

// splice(index, howmany, elements)
// index 위치 뒤에 howmany만큼의 값을 배열에서 제거한 후 elements를 추가한다. howmany가 0일 경우 기존의 원소를 제거하지 않는다. 

/*
let li = ['a', 'b', 'c', 'd', 'e']
li.shift();
alert(li);
// shift = 배열의 첫 번째 원소 제거

let li = ['a', 'b', 'c', 'd', 'e']
li.pop();
alert(li);
// pop = 배열의 마지막 원소 제거

let li = ['a', 'b', 'c', 'd', 'e']
li.sort();
alert(li);
// sort = 정순정렬

let li = ['a', 'b', 'c', 'd', 'e']
li.reverse();
alert(li);
// reverse = 역순정렬
*/

</script>

</body>
</html>